We start with a node and do dfs on each unvisited node we increment the low and tin count of current node and do dfs from that node. If we have a visited node as a child we update the low of curr node with its adjacent nodes. On completing dfs call at each node, we check if tin[curr] < low[child] if this condition holds good this is a bridge. Because if the child node has low time > curr ins time, it means there is no back edge for child node and we must visited parent before child and there is no other way to reach child. So it indicates a bridge.
We dont compare curr with its parent node to update low because we need a backedge from anther node not from parent.